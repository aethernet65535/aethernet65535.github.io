---
title: "XV6-2020: LAB6-COW"
published: 2025-06-25
description: "怎么操作系统还有牛牛？"
image: "./lab6.jpg"
tags: ["xv6"]
category: OS
draft: false
---

## 前言（废话）
这个不算太容易，有个地方困扰了我很久，不过我目前还是没发现为什么就是了，之后可能会去仔细研究（调试？）。        
不过现在的话，我就先整理一些资料给读者们和未来的自己而已。      
我想更多的是整理给未来的自己，就是当作一个学习笔记！    
不过整理给自己也很好就是了，如果屏幕前的读者觉得自己学了但是不理解的话，可以试试写笔记写博客之类的，你要写出你理解的东西，不理解的现在就去学。      
这样的话有助于更好的理解你所学到的，即使之后忘了也没关系，再回来看，努力记住！      

## 问题
**XV6**现在的`fork()`有什么问题呢？       
现在是这样的，当调用`fork()`时，系统就会复制父进程，然后创建同样多的物理页，全复制给子进程。      
不是映射哦，是完全复制，就像克隆一样呢，完全复制，和我们之前做的那种内核页表映射不同。

这样做有什么问题吗？        
当然有，问题就是用了太多内存了。        
比如我要创建一个子进程，但是其实它只需要查看父进程的东西而已。      
之后我创建了一个进程，叫`foo`，然后我在里面放了很多资料，我需要一个子进程帮我查看资料。     
于是我就创建了一个`bar`子进程，它只需要查看`foo`进程里的数据，然后条件筛选返回给用户就可以了。      
这样的话，是不是其实它做的**写入**操作是很少很少的呢？对！      
那这样也就是说，我们浪费了很多不该浪费的内存，因为两个进程拥有超级多一样的数据，但是却也有双倍的内存大小！      

读者们也觉得这样很不好，对吧？      
所以**XV6**就要我们学会优化这东西，我们要让那些有父子关系的或者后代在一个物理页内有相同数据时，尽可能让它们使用同一个物理页，以此来节省好多内存！（也有可能很少，但是反正这是好事！）

## 思路
所以，我们就需要思考，要怎么优化呢？        
首先我们已经知道了一个东西，就是**物理页**相同的话，就要让它们指向同一个**物理页**，而不是创建多一个。      

但是这样的话，如果某个进程去修改了**那一个物理页**，那么就会影响到那些同样映射着那个**物理页**的进程不是吗？      
我们现在又知道了，如果某个进程要修改的话，就一定不能让它影响其他进程。      
那么应该怎么做，答案就是，当我们知道有某个进程想要修改某个**多进程映射的物理页**时，就自动创建一个**独立的物理页**给那个某某进程。      

诶，但是，我们要怎么知道进程要对某个**物理页**进行修改，并且及时干涉呢？        
简单，当进程想要修改**物理页**的时候，它要干什么？      
没错，就是**写入**，进程需要**写入**才可以修改，对吧？      
而且呀，我们上一个**LAB**不就是**LAZYALLOC**吗？**COW**其实也差不多，不过更复杂而已。       

虽然我们知道了可以用**写入**来判断，但是要怎么知道进程要**写入**了呢？每次**写入**都要检查吗？那样对于我们这些初学者就太不方便了（至少我是，读者们可能都是大佬！）。        
所以我们可以这样，当某个进程调用`fork()`的时候，就去除双方（old和new）所有**物理页的写入权限**，这样它们**写入**的时候就会报**15号错误（STORE）**，这个时候我们就可以给它创建一个**独立的物理页**了，然后它就可以更改且不影响其他进程了。

但是呀，当某个进程试图对那些**不可写入**的**物理页**写入时，我们也得阻止，加个标识符就行了，就叫...**PTE_COW**吧！这个很容易记得对吧！ヾ(≧▽≦*)o

## implement copy-on-write (hard)
我重复下**XV6**说过的话，就是要求之类的东西。

### 通过条件
只要修改后的内核通过了`cowtest`和`usertests`程序，那就算你通过了此测试。

### 解题思路（提示）
- 修改`uvmcopy()`，使其不再使用`kalloc()`分配物理页，而是将父进程的**物理页**都映射到子进程的**物理页**，并且记得要消除双方的**PTE_W**。
- 修改`usertrap()`，使其对**15号错误有某种特殊处理**，当**COW**页出现错误时，使用`kalloc()`分配**物理页**，并将旧页的内容复制到新**物理页**，当然也不能忘了添加**PTE_W**权限。
- 确保每个**物理页**，只有在没有任何进程引用时才释放。添加**引用次数**是一种不错的方法。
使用`kalloc()`分配**物理页**时，**设置**其**引用次数为1**（注意是设置，尽量别预设引用次数为0，博主预设了，所以在某个地方卡了很久）。
当`uvmcopy()`时，就把**引用次数+1**，相反的，在你的`某某函数()`给**物理页**独立出来时，也必须对之前映射的**物理页**的**引用次数-1**。
只有在**引用次数==0**时，才可以释放该**物理页**。
你可以使用数组来管理**引用次数**，例如`uint16 pgrfc[(PHYSTOP - KERNBASE) / PGSIZE]`。
- 你可以使用**自旋锁**来保护该数组的资源。
- 修改`copyout()`，让其与**页错误**使用相同的处理方案。
- 这和`lazy allocation`那个作业差不多，可以参考。但是别基于那个分支做，要遵守规则，用新分支来做哦。
- 关于`PTE_COW`，可以看看**RISC-V**的一些资料，搜搜**RSW**，为软件保留的PTE位，很有用的哦。

	>再给点额外提示，**SV39**的**PTE位**从**0-8**分别是`V, R, W, X, U, G, A, D, RSW`。哎呀哪个是能存`PTE_COW`的呢，好难猜呀||ヽ(*￣▽￣*)ノミ|Ю

- 如果发生`COW`错误时，内存不足了，就该终止该进程。
- 当进程试图写入**不可写入**且**不是COW的物理页**时，那么最简单的方法应该是终止该进程。

	>原因如下：
	>- 内核不该修改或跳过用户的某段指令，这不是内核该做的，而且这一般只会让情况更遭。
	>- 内核可以返回错误信息，但是这是极其复杂的。

	>PS: 你看着可能会觉得我说的有点尖锐，不过我绝对没有要故意尖锐的意思哦，只是提醒而已，读者们千万不要想什么终止进程以外的方案。我是说，可以想，但是最好不要尝试在作业中优化这个东西，很复杂的！！（是大佬的话当我没说(￣▽￣)"））

### 解决方案（实现）
首先我们需要先完成两个重要的东西，**引用次数的数组**以及保护其的**自旋锁**（SPINLOCK）。		

#### 引用次数的数组
我们先来清除一下，我们需要有多少个地方需要存我们的引用次数呢？大概就是所有常用页都需要，对吧？		
所以我们就做简单的，只要做`KERNBASE`到`PHYSTOP`这段距离的就行了，我们不弄其他的，这样更简单对吧？		

那么我们就来创建一个数组：`kalloc.c`		
```C
static uint16 pgrfc[(PHYSTOP - KERNBASE) / PGSIZE];
```

顺便做一下一个好用的索引，这个用的有点频繁，所以就做了个，你要自己打也行：
```C
#define index_rfc(pa) ((pa - KERNBASE) >> 12) // 等价于(pa - KERNBASE) / PGSIZE
```

#### 自旋锁
其实我们可以从代码里看到大概是怎么做自旋锁的，很简单，看一眼就会了。		

首先先声明一下这个锁：		
```C
struct spinlock rfc_lock;
```

之后，就直接创建就行了，那个字符串要写引用次数的数组变量名：
```C
void
kinit()
{
  initlock(&kmem.lock, "kmem");
  initlock(&rfc_lock, "pgrfc"); // 这行是新增的
  freerange(end, (void*)PHYSTOP);
}
```

#### 改变引用次数
我用了三个函数来解决这些问题，说实话，你真想的话，一个函数都不写也没问题，不过你可以考虑优化我的方案，我的肯定不是最好的。

首先，第一个是自增函数（要说是自减也行）：
```C
int
add_pgrfc(uint64 pa, int n)
{
  // 这个可以说基本触发不了，内核代码都是自己写的，能报错就有鬼了
  // 不过以防万一，加一下，安全检查总归不是坏事
  if((int)pgrfc[index_rfc(pa)] + n < 0 ||
     (int)pgrfc[index_rfc(pa)] + n > 65535){
    panic("set_pgrfc: too big or too small");
    return -1;
  }

  pgrfc[index_rfc(pa)] += n;
  return 0;
}
```

其次是设置函数，完全根据用户的输入来决定该物理页的引用次数：
```C
void
set_pgrfc(uint64 pa, int n)
{
  // 充满血与泪的一行	
  pgrfc[index_rfc(pa)] = n;
}
```

最后就是获取函数，只是返回该物理页的引用次数而已：
```C
uint16
get_pgrfc(uint64 pa)
{
  return pgrfc[index_rfc(pa)];
}
```

#### 释放与初始化
在`kalloc.c/kfree`里，我们得添加一个新东西，就是禁止引用次数非0的物理页被释放，我们要做的仅仅只是对引用次数为大于1的物理页，将其的引用次数-1后再检查：
```C
if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)
  panic("kfree");

acquire(&rfc_lock); // 开锁，这样就只有我能碰这个数组了
uint16 rfc = get_pgrfc((uint64)pa);
if(rfc > 1){
  add_pgrfc((uint64)pa, -1);
  release(&rfc_lock); // 好，现在谁都可以碰了
  return;
}
release(&rfc_lock); // 一样，谁都可以碰了
```

之后，我们要确保`kalloc.c/kalloc`所分配的物理页，引用次数绝对为1，所以要直接设置：
```C
if(r){
    memset((char*)r, 5, PGSIZE); // fill with junk
    set_pgrfc((uint64)r, 1); // 这里一定得用set，你可能觉得add也一样
							 // 但是不要默认所有进来freelist的物理页引用次数都为0
							 // 博主可以说大部分时间都卡在这里了
							 // 如果你不愿相信的话，可以试试自己printf所有引用次数，看看是不是都为0
  }
  return (void*)r;
```

#### COW & FORK
首先，我们要先来做一个`COW`识别符，不能对所有**不可写入的物理页**用同一种解决方案，毕竟有些页本来就是不希望用户写入的。       
那么这个`COW`就要用我们刚刚找到的那个`RSW`，也就是**第8位**。   

在`riscv.h`文件写上：
```C
#define PTE_COW (1L << 8) // 
```

然后我们得稍微修修`vm.c/uvmcopy()`，但是在那之前，我们先看我们需要什么，不需要什么。    
首先，毫无疑问的，我们不需要`kalloc()`了，因为我们不希望这个`fork()`会直接分配新的物理页。    
所以这些代码我们不需要了，删掉。
```C
char *mem; // 不删这个可能会用unused var之类的报错

if((mem = kalloc()) == 0)
  goto err;

memmove(mem, (char*)pa, PGSIZE);
if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0){
  kfree(mem);
  goto err;
}
```
然后我们希望双方都有COW+NO_WRITE，对吧？    
所以我们得这样写：
```C
flags = PTE_FLAGS(*pte);

*pte = (*pte & ~PTE_W) | PTE_COW; // 现在被打上COW标签了，而且再也不能写入了！！

acquire(&rfc_lock);
add_pgrfc(pa, 1); // 加一，如果之后出问题了会在kfree那里自己减的
release(&rfc_lock);

if(mappages(new, i, PGSIZE, pa, (flags & ~PTE_W)|PTE_COW) != 0) // mem得改成pa，因为这次是映射而不是分配
  goto err;
```

#### 报错处理
之后有任何一方要对该物理页进行写入操作时，一定会报错，所以我们要处理这个报错！    
和之前做Lazy Allocation时一样，都是要在`trap.c/usertrap()`处理：    
```C
else if (r_scause() == 15){
    uint64 stval = r_stval();
    if(cow(stval, p) != 0)
      p->killed = 1;
}
```

而实现是这样的，要在哪都可以，不过我推荐放`vm.c`：
```C
int
cow(uint64 va, struct proc *p)
{
  pte_t *pte = walk(p->pagetable, va, 0);
  if(*pte & PTE_COW){
    char *mem;
    uint64 pa = PTE2PA(*pte); // 获取物理页地址

    if((mem = kalloc()) == 0) // 创建新的物理页
      return -1;

    memmove(mem, (char*)pa, PGSIZE); // 把当前物理页的内容搬到新物理页
    kfree((char*)pa); // 直接尝试释放即可，该函数会自行处理引用次数
    
    pte_t newpte = PA2PTE(mem); // 创建一个指向新物理页的PTE
    newpte = ((newpte | PTE_FLAGS(*pte)) | PTE_W) & ~PTE_COW; // 新PTE含有旧PTE的FLAGS，且允许写入，并且不再会（暂时）被是为COW页
    *pte = newpte; // 用新PTE替代旧PTE
  } else
      return -2;  // 也可以选择别的返回值
                  // -2只是为了区分，读者们可以在完成后尝试对-2做特殊处理

  return 0;
}
```

#### 小修小补
提示那里有说了要改`copyout()`，我相信读者们绝对没有忘记！   
所以我现在我们要来改哪个地方了！    
好，我们先看看，哪里有问题呢？
```C
memmove((void *)(pa0 + (dstva - va0)), src, n); // 这一行存在对COW页写入的可能性
```
但是呢，`memmove()`其实是预期行为对吧？我们不需要删掉它，我们要做的是让它变的再次正确。   
方法就是，修改**pa**。

```C
while(len > 0){
  va0 = PGROUNDDOWN(dstva);
  pa0 = walkaddr(pagetable, va0);
  if(pa0 == 0)
    return -1;
  // 现在确认了当前pa是有效的
  //如果它是COW物理页的话，就会更新它的PTE
  if(cow(va0, myproc()) == -1) // 如果内存不足了，就终止该进程
    myproc()->killed = 1; 
  pa0 = walkaddr(pagetable, va0); // 这里就是用了新的PTE，也就有了新的pa
```
这里的话呢，就算我们处理的物理页不是COW页，也是不会出什么问题的。   
因为呢，我们的`cow()`会直接跳过所有东西，然后返回-2错误，但是-2错误对这里来说，几乎就是不做任何事的意思了。   
所以结论就是，它很好的保证了安全，也没有让其他东西变的不安全！

## 完结撒花
还有问题的话，推荐读者们用`printf()`和**gdb**来调试，不过`printf()`一般只适合那种无需写入的调试，因为其很容易出问题呢（；´д｀）ゞ。   
读者们可以学一下gdb的用法，很好用的，我目前还没有很熟练，但是也觉得很好用了呢，熟练了想必会更好用！   
(๑•̀ㅂ•́)و✧

最后编辑时间：2025/06/26
